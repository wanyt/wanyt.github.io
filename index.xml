<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Terminal</title>
    <link>/</link>
    <description>Recent content on Terminal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Sep 2020 18:07:23 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>interrupt.md</title>
      <link>/posts/interrupt/</link>
      <pubDate>Wed, 02 Sep 2020 18:07:23 +0800</pubDate>
      
      <guid>/posts/interrupt/</guid>
      <description>&lt;p&gt;线程停止
Java没有提供任何机制让线程停止下来，只有::当线程的任务执行完成::或者::线程抛出了异常（且没有被捕获）::，它才会停止。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>synchronized</title>
      <link>/posts/text/</link>
      <pubDate>Wed, 02 Sep 2020 18:07:23 +0800</pubDate>
      
      <guid>/posts/text/</guid>
      <description>&lt;p&gt;synchronized &amp;amp; volatile
synchronized能够保证在同一时刻最多只有一个线程执行该段diamante，保证了并发安全的效果。&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象锁：包含方法锁（锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）&lt;/li&gt;
&lt;li&gt;类锁：synchronized修饰静态方法，锁是当前类的class对象；由于每个类在JVM中只有一个class对象，那么类锁中的代码块在同一时刻仅有一个线程可操作性，且达到了全局同步的效果&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0-%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB/</guid>
      <description>锁的种类 偏向锁/轻量级锁/重量级锁 这三种锁特指synchronized的状态，通过在对象头中的mark word来表明锁状态。
 偏向锁；如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。 轻量级锁；JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。 重量级锁；重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。  综上所述，偏向锁性能最好，可以避免执行 CAS 操作。而轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。
可重入锁/非可重入锁 可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。
对于可重入锁而言，最典型的就是 ReentrantLock 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类。
共享锁/独占锁 ::共享锁::指的是我们同一把锁可以被多个线程同时获得，而::独占锁::指的就是，这把锁只能同时被一个线程获得。我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有
公平锁/非公平锁 ::公平锁::的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。
::非公平锁::就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。
悲观锁/乐观锁 ::悲观锁::的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。
悲观锁比较悲观，它认为如果不锁住这个资源，别的线程就会来争抢，就会造成数据结果错误，所以悲观锁为了确保结果的正确性，会在每次获取并修改数据时，都把数据锁住，让其他线程无法访问该数据，这样就可以确保数据内容万无一失。
::乐观锁::不要求在获取资源前拿到锁，也不会锁住资源；乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。
乐观锁比较乐观，认为自己在操作资源的时候不会有其他线程来干扰，所以并不会锁住被操作对象，不会不让别的线程来接触它，同时，为了确保数据正确性，在更新之前，会去对比在我修改数据期间，数据有没有被其他线程修改过：如果没被修改过，就说明真的只有我自己在操作，那我就可以正常的修改数据；如果发现数据和我一开始拿到的不一样了，说明其他线程在这段时间内修改过数据，那说明我迟了一步，所以我会放弃这次修改，并选择报错、重试等策略。
有一种说法认为，悲观锁由于它的操作比较重量级，不能多个线程并行执行，而且还会有上下文切换等动作，所以悲观锁的性能不如乐观锁好，应该尽量避免用悲观锁，这种说法是不正确的。
因为虽然悲观锁确实会让得不到锁的线程阻塞，但是这种开销是固定的。悲观锁的原始开销确实要高于乐观锁，但是特点是一劳永逸，就算一直拿不到锁，也不会对开销造成额外的影响。
反观乐观锁虽然一开始的开销比悲观锁小，但是如果一直拿不到锁，或者并发量大，竞争激烈，导致不停重试，那么消耗的资源也会越来越多，甚至开销会超过悲观锁。
悲观锁适合用于并发写入多、临界区代码复杂、竞争激烈等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。
乐观锁适用于大部分是读取，少部分是修改的场景，也适合虽然读写都很多，但是并发并不激烈的场景。在这些场景下，乐观锁不加锁的特点能让性能大幅提高。
自旋锁/非自旋锁 ::自旋锁::的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。
::非自旋锁::的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。
可中断锁/不可中断锁 中断指的是获取锁的操作是否可以中断。
在 Java 中，synchronized 关键字修饰的锁代表的是::不可中断锁::，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。
而 ReentrantLock 是一种典型的::可中断锁::，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>Kotlin扩展方法 #默认分类/Kotlin
kotlin的扩展方法被解析成静态方法，那为什么在扩展方法中可以直接调用类的成员方法和成员变量呢？这不是很奇怪吗？kotlin使用了什么样的魔法可以让静态方法调用累的成员方法。
编写ExtA.kt，然后添加成员方法testA()和扩展方法testB()：
class ExtA { fun testA(){ print(“abcd”) } } fun ExtA.testB(){ testA() } 在扩展方法testB()中调用了成员方法testA()，编译没报错，并且能运行成功。kotlin肯定使用什么语法糖能在静态方法中调用成员方法。现在看一下testB()编译后的java代码：
public static final void testB(@NotNull ExtA $this$testB) { Intrinsics.checkParameterIsNotNull($this$testB, &amp;quot;$this$testB&amp;quot;); $this$testB.testA(); } testB()确实被编译成静态方法了，但是无参的testB()变成了含参的testB(ExtA)，而testB()中调用testA()使用了参数的应用调用的。谜团差不多有解了，是因为成员引用被传递到扩展方法中，扩展方法调用了引用的成员方法。
再创建ExtB.kt，在ExtB.kt中调用扩展方法testB()：
class ExtB { fun main(){ val a = ExtA() a.testB() } } ExtB.kt编译后的java代码：
public final class ExtB { public final void main() { ExtA a = new ExtA(); ExtsKt.testB(a); } } 这样看就很清晰了，kotlin的扩展方法就是语法糖，本质还是静态方法而已；但不得不说它就是很甜。</description>
    </item>
    
  </channel>
</rss>