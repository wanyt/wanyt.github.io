<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>Gridea</title>
    <updated>2019-11-20T03:49:30.802Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[H]]></title>
        <id>http://localhost:4000/post/h</id>
        <link href="http://localhost:4000/post/h">
        </link>
        <updated>2019-11-18T07:14:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="handler和内存泄漏">Handler和内存泄漏</h1>
<p>面试经常会问什么操作会产生内存泄漏？</p>
<p>本文章验证三个问题：</p>
<ol>
<li>Handler如何造成内存泄漏</li>
<li>Handler导致内存泄漏的影响如何</li>
<li>如何避免Handler造成的内存泄漏</li>
</ol>
<h2 id="profile简单使用">Profile简单使用</h2>
<h2 id="handler如何造成内存泄漏">Handler如何造成内存泄漏</h2>
<h2 id="handler导致内存泄漏的影响如何">Handler导致内存泄漏的影响如何</h2>
<h2 id="如何避免handler造成的内存泄漏">如何避免Handler造成的内存泄漏</h2>
<ol>
<li>信令是怎么处理的？sfu是不传递信令的</li>
</ol>
<p>#blog</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter页面导航（一）]]></title>
        <id>http://localhost:4000/post/flutter-ye-mian-dao-hang-yi</id>
        <link href="http://localhost:4000/post/flutter-ye-mian-dao-hang-yi">
        </link>
        <updated>2019-10-27T14:08:22.000Z</updated>
        <content type="html"><![CDATA[<p>我刚接触Flutter的页面跳转会感觉有点怪异，主要还是对Dart语法不熟悉。Android，IOS应用中的页面在Flutter中被叫做Route，应用中的所有的Route被Navigator统一管理。Navigator定义了一系列页面跳转的方法，比如<code>Navigator.push()</code>，<code>Navigator.pop()</code>。Navigator是继承自StatefulWidget的Widget（没错Flutter里一切都是Widget）。</p>
<p>上面列举的两个方法<code>Navigator.push()</code>和<code>Navigator.pop()</code>分别对应打开页面和关闭页面。在Flutter中，打开页面又分为使用Route对象打开——push()系列方法和按照路径打开——pushNamed()系列方法。</p>
<h2 id="push">push()</h2>
<p><code>static Future&lt;T&gt; push&lt;T extends Object&gt;(BuildContext context, Route&lt;T&gt; route)</code></p>
<p><code>push()</code>是打开页面最常用的方法之一。第一个参数context是上下文，在StatelessWidget和StatefulWidget中都能获取到；第二个参数route是Route对象，它包含了的被打开的页面信息，一般使用<code>MaterialPageRoute</code>。看下用法：</p>
<pre><code>class PushPageA extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new Scaffold(
        appBar: new AppBar(
          title: new Text(&quot;Page A&quot;),
        ),
        body: new Center(
            child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: &lt;Widget&gt;[
              new RaisedButton(
                  onPressed: () {
                    Navigator.push(context,
                        MaterialPageRoute(builder: (context) {
                          return PushPageB();
                        }));
                },
                child: new Text(&quot;push to B&quot;)),
          ],
        )));
  }
}

class PushPageB extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new Scaffold(
        appBar: new AppBar(
          title: new Text(&quot;Page B&quot;),
        ),
        body: new Text(&quot;this is page B&quot;));
  }
}
</code></pre>
<p>这样就打开了另一个页面，很简单吧！但是一个简单的跳转居然要我写四行代码，我也是醉了。有没有简单一点的写法，当然有：</p>
<pre><code>Navigator.push(context,
    MaterialPageRoute(builder: (context) =&gt; PushPageB()));
</code></pre>
<p>我们使用胖箭头语法把四行代码变成了两行，相对于上面的跳转代码来说更加易读了。但还是有点啰嗦，有没有更简练的语法。当然有~</p>
<blockquote>
<p>MaterialPageRoute是Route的子类，它是最常用的构建Route的类。也可以往方法里传入其他的Route子类，也可以自定义Route。</p>
</blockquote>
<h2 id="pushnamed">pushNamed()</h2>
<p><code>Future&lt;T&gt; pushNamed&lt;T extends Object&gt;(BuildContext context, String routeName)</code></p>
<p><code>pushNamed()</code>是使用路径名称的方式打开页面。第二个参数routeName就是页面的路径。要想使用这种跳转方式要分两步走：1. 定义页面路径；2. 使用页面路径跳转。</p>
<p>首先，定义页面路径。在应用mainApp的build()中返回MaterialApp()，然后在MaterialApp()的<em>routes</em>属性中定义路径并给路径赋值，页面路径要使用<code>‘/a/b/c’</code>这样的格式，默认情况下，应用主页面的路径是”/“，也可以使用<em>initialRoute</em>修改主页面路径，不过没啥修改的必要。OK，上代码：</p>
<pre><code>void main() =&gt; runApp(new MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new MaterialApp(
      theme: new ThemeData(
        primarySwatch: Colors.brown,
      ),
//      home: new MyHomePage(title: 'Navigation Demo'),
      routes: {
        &quot;/&quot;: (context) =&gt; new MyHomePage(title: 'Navigation Demo'),
        &quot;/page2&quot;: (context) =&gt; new Page2(),
      },
    );
  }
}
</code></pre>
<p>这样就定义好路径，后面就可以使用它们进行跳转。但是有两点需要注意的地方。</p>
<ol>
<li>上面的代码注释了<em>home</em>属性，<em>route</em>属性中<code>&quot;/&quot;: (context) =&gt; new MyHomePage()</code>这行代码指定了主界面是MyHomePage。如果们在<em>route</em>中即使用了”/“指定主页面，又使用了<em>home</em>属性，这时运行应用是会抛出异常的。<em>home</em>和<em>route</em>中的”/“只能选择一个。</li>
<li>我能不能在其他页面的<code>build()</code>中创建一个MaterialApp()，在这个页面的<em>route</em>属性中定义路径可以吗？不可以，只能在<code>main()</code>的MaterialApp()中定义。如果在其他页面的MaterialApp()中定义了路径，然后执行<code>pushName()</code>进行跳转，会抛出异常：Another exception was thrown: Could not find a generator for route “/routeName” in the _WidgetsAppState。</li>
</ol>
<p>现在就可以使用pushNamed()进行跳转了：</p>
<pre><code>···
Navigator.pushNamed(context, &quot;/page2&quot;);
···
</code></pre>
<p><code>pushNamed()</code>用法比较简单直观，虽然要配置路径，但也是一劳永逸的事情。</p>
<h2 id="pop">pop()</h2>
<p><code>bool pop&lt;T extends Object&gt;(BuildContext context, [ T result ])</code></p>
<p>直接调用<code>pop(context)</code>即可关闭页面。在<em>initialRoute</em>页面，也就是主页面调用<code>pop(context)</code>会显示空白页面（一些机型会显示全黑的页面）。也就是说在一些界面可以调用<code>pop(context)</code>，一些界面不可以。那我们怎么判断在当前页面能不能调用<code>pop(context)</code>呢？</p>
<h2 id="canpop">canPop()</h2>
<p><code>bool canPop(BuildContext context)</code></p>
<p>canPop()返回一个布尔值，告诉调用者当前页面是否可以调用<code>pop(context)</code>。这个方法返回false的情况有两种：</p>
<ol>
<li><em>initialRoute</em>，被标记为<em>initialRoute</em>的页面不能执行pop()。在这个页面执行pop()要么报错，要么显示一个空白页面。</li>
<li>在当前的上下文里没有Navigator的时候会返回false。</li>
</ol>
<h2 id="maybepop">maybePop()</h2>
<p><code>maybePop&lt;T extends Object&gt;(BuildContext context, [ T result ])</code></p>
<p>在<em>initialRoute</em>页面执行pop()会显示空白页面，或者报错。我们不能在这个页面执行pop()。如果不确定在某个页面能不能执行pop()。就需要判断一下再执行：</p>
<pre><code>if(Navigator.canPop(context)){
    Navigator.pop(context);
}
</code></pre>
<p><code>maybePop()</code>在内部帮助我们做了判断。当前页面如果可以被pop就执行<code>pop()</code>，如果不可以就不执行。我们在<em>initialRoute</em>页面执行这个方法是没有任何表现的，在其他页面执行会正常关闭当前页面。</p>
<h2 id="关闭页面并返回值">关闭页面并返回值</h2>
<p>Android里面的<code>startActivityForResult()</code>，次级页面完成后关闭，然后往一级页面返回值。Flutter中也有对应的机制。我们再看一下pop()：</p>
<pre><code>bool pop&lt;T extends Object&gt;(BuildContext context, [ T result ])
</code></pre>
<p>第二个参数result就是返回给上级页面的值，它可以是任何类型。我们再看一下打开页面的代码：</p>
<pre><code>static Future&lt;T&gt; push&lt;T extends Object&gt;(BuildContext context, Route&lt;T&gt; route)
</code></pre>
<p>它的返回值类型是Future<T>，他就代表从上个页面返回的值，看下完整的代码：</p>
<pre><code>// 一级页面打开次级页面的代码
_pushToPage2() async {
    String result = await Navigator.push(
        context, MaterialPageRoute(builder: (context) =&gt; Page2()));
    print(&quot;$tag $result&quot;);
}

//次级页面返回的代码
Navigator.pop(context, &quot;这是返回值&quot;);
</code></pre>
<h2 id="页面传值">页面传值</h2>
<p>在Android中通过Intent给其他页面传值，先创建Intent()然后把Intent传给<code>startActivity()</code>，在下个页面获取到Intent后拿数据。在Flutter中这个流程就要简单的多，直接把数据放到页面的构造函数中。这种方式就比较直觉简单。代码还用上面的例子：</p>
<pre><code>// 一级页面打开次级页面的代码
_pushToPage2() async {
    String result = await Navigator.push(
        context, MaterialPageRoute(builder: (context) =&gt; Page2()));
    print(&quot;$tag $result&quot;);
}

class Page2 extends StatelessWidget {
  String data;
  Page2({Key key, this.data}): super(key: key);

  @override
  Widget build(BuildContext context) {
    return new Scaffold(
      appBar: AppBar(
        title: new Text(&quot;第二个页面&quot;),
      ),
      body: new Center(
        child: Column(children: &lt;Widget&gt;[
          new Text(data),
        ],)
      ),
    );
  }
}
</code></pre>
<p>Flutter的页面传值就简单，但使用<code>pushNamed()</code>是没有办法进行传值的。</p>
<p>#android/flutter<br>
#blog</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Handler]]></title>
        <id>http://localhost:4000/post/handler-ji-zhi</id>
        <link href="http://localhost:4000/post/handler-ji-zhi">
        </link>
        <updated>2019-10-27T14:07:22.000Z</updated>
        <summary type="html"><![CDATA[<p>想象这样一个场景：我在淘宝下个订单，订单上包含我的姓名和地址、货物名称等，商家把订单打包后交给顺丰，顺丰把订单运到北京的集散中心，集散中心根据订单上的姓名和地址把货物派送给我。这是网购的流程，和Handler机制有异曲同工之处：</p>
]]></summary>
        <content type="html"><![CDATA[<p>想象这样一个场景：我在淘宝下个订单，订单上包含我的姓名和地址、货物名称等，商家把订单打包后交给顺丰，顺丰把订单运到北京的集散中心，集散中心根据订单上的姓名和地址把货物派送给我。这是网购的流程，和Handler机制有异曲同工之处：</p>
<!-- more -->
<ol>
<li>我 —— Handler，我下订单就是<code>handler.post()</code>，订单经过转运之后还是交给我；Handler发消息的最终目的地还是Handler的回调处理消息</li>
<li>订单 —— Message，订单里包含收货地址，货物等，就是<code>msg.target</code>、<code>msg.what</code>、<code>msg.data</code>，Message是消息传递的介质</li>
<li>顺丰 —— MessageQueue，这个很好理解，MessageQueue就是搬运工，根据消息的时间先后顺序分发消息</li>
<li>集散中心 —— Looper，集散中心一直阻塞在这里等待新的货物到达，然后根据订单上的地址分发快递；Looper在for循环里一直获取最新的消息，如果有新消息就根据<code>msg.target</code>获取到handler然后调用<code>dispatchMessage()</code>把消息分发下去，最后触发Handler的Callback回调</li>
</ol>
<p>虽然这个例子并没有完美的契合Handler的运行机制（还有商家没有对应到Handler），但是对于理解Handler是十分有帮助的。</p>
<p>Handler是Android应用层中广泛使用的多线程通信组件。Handler的用途表现在两个方面：（1）延时执行Runnable或延时发送Message；（2）线程间通信，给其他线程发消息，通知其他线程执行操作。</p>
<p>整个Handler机制包含四个角色：</p>
<ul>
<li><code>Handler</code>，它是开发者直接操作的对象，它参与了消息分发流程中发送和处理消息的过程</li>
<li><code>Message</code>，是消息传递的介质，传递的数据要包装成Message</li>
<li><code>MessageQueue</code>，开发者几乎无法接触，它操作了消息的入队和出队</li>
<li><code>Looper</code>，消息分发的核心，整个流程的心脏</li>
</ul>
<p>Android面试经常会问Handler，虽然这是一个老生常谈的话题，但真正搞明白还是要花费一番功夫，比如：</p>
<ol>
<li>Handler的运行机制是什么样的？</li>
<li>子线程中可以直接创建Handler吗？</li>
<li>官方文档为什么推荐使用Message.obtain()创建Message？</li>
<li>Handler是怎么造成内存泄漏的？在Activity中创建Handler成员变量一定会造成内存泄漏吗？</li>
</ol>
<p>本文会一一解答上面的问题。现在先依次介绍Handler的四个角色，介绍完Handler的整个运行机制就会很清晰。</p>
<h2 id="handler">Handler</h2>
<p>Handler负责发送和处理Message。在哪个线程创建Handler，它就属于哪个线程；比如，在Activity中创建Handler实例，那么这个Handler就和主线程绑定了。当然，在Activity中创建Handler的匿名内部类变量可能会造成内存泄漏</p>
<p>通过方法名和参数可以把Handler的发送操作分为两个系列：</p>
<ol>
<li><code>post()</code>系列方法，它是用来发送Runnable对象到MessageQueue中。如，<code>post(Runnable r)</code>、<code>postAtTime(Runnable r, long uptimeMillis)</code>、<code>postDelayed(Runnable r, long delayMillis)</code>等</li>
<li><code>send()</code>系列方法，它是用来发送Message对象到MessageQueue中。如，<code>sendMessage(Message msg)</code>、<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>、<code>sendMessageDelayed(Message msg, long delayMillis)</code>等<br>
这两个系列的方法分别用来发送和处理Runnable和Message对象；Runnable在Handler中也会被包装成Message发送给MessageQueue。</li>
</ol>
<h3 id="创建">创建</h3>
<p>Handler提供了多个构造函数，创建Handler最常用的构造函数是：</p>
<pre><code>public Handler(@Nullable Callback callback) {
    this(callback, false);
}

public Handler(@Nullable Callback callback, boolean async) {
    …省略代码…
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            “Can’t create handler inside thread “ + Thread.currentThread()
                    + “ that has not called Looper.prepare()”);
    }
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
</code></pre>
<p>在构造函数中，Handler获取了mLooper和mQueue的实例。这也说明了，Handler和Looper绑定，Handler唯一对应一个Looper，Looper运行在哪个线程Handler就属于哪个线程。</p>
<p>::子线程中可以直接创建Handler吗？::<br>
”不可以，会抛出运行时异常，需要先调用<code>Looper.prepare()</code>。”当然，这是一个正确但不严谨的回答。</p>
<pre><code>	val runnable = Runnable {  Handler()  }
  Thread(runnable).start()
</code></pre>
<p>运行上面的代码会报错：<code>java.lang.RuntimeException: Can't create handler inside thread Thread[Thread-2,5,main] that has not called Looper.prepare()</code>。子线程没有运行Looper。</p>
<p>确定不可以在子线程直接创建Handler吗？当然可以。Handler提供了下面的构造函数：</p>
<pre><code>public Handler(@NonNull Looper looper, @Nullable Callback callback) {
    this(looper, callback, false);
}
</code></pre>
<p>给Handler的构造函数传Looper，Handler会绑定到Looper运行的线程：</p>
<pre><code>val runnable = Runnable {
		val handler = Handler(Looper.getMainLooper())
		handler.post { //更新UI }
}
Thread(runnable).start()
</code></pre>
<p>通过这种方式创建的<code>handler</code>运行在主线程，<code>handler.post(Runnable)</code>就可以在该Runnable中直接对UI进行更新。</p>
<p>子线程创建Handler的另一个更通用的方法是调用<code>Looper.prepare()</code>，先让子线程运行Looper：</p>
<pre><code>	val runnable = Runnable {
		Looper.prepare()
		Looper.loop()
      val rHandler = Handler()
  }
  Thread(runnable).start()
</code></pre>
<p><code>rHandler</code>是子线程的Handler()，其他线程获取到<code>rHandler</code>就可以给它发送Message和Runnable，实现线程间通信。</p>
<p>回到上面的问题，::子线程中可以直接创建Handler吗？:: 子线程创建Handler有两种方式：</p>
<ol>
<li>最常用的方式是先调用<code>Looper.prepare()</code>和<code>Looper.loop()</code>让子线程运行Looper，然后再创建Handler；如果子线程已经运行了Looper，那就可以直接创建Handler。通过这种方式创建的Handler是运行在子线程的。</li>
<li>可以通过<code>Handler(Looper looper)</code>在子线程创建Handler。通过这种方式创建的Handler和参数中looper运行在同一个线程；比如，在子线程中调用<code>Handler(Looper.getMainLooper())</code>，创建的Handler是运行在主线程的。</li>
</ol>
<h3 id="消息入队">消息入队</h3>
<p><code>post()</code>系列方法会先调用<code>getPostMessage(Runnable r)</code>把Runnable包装成Message，然后再进行入队操作：</p>
<pre><code>public final boolean post(@NonNull Runnable r) {
   return  sendMessageDelayed(getPostMessage(r), 0);
}

public final boolean postAtTime(@NonNull Runnable r, long uptimeMillis) {
    return sendMessageAtTime(getPostMessage(r), uptimeMillis);
}

public final boolean postDelayed(@NonNull Runnable r, long delayMillis) {
    return sendMessageDelayed(getPostMessage(r), delayMillis);
}

private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
</code></pre>
<p><code>post()</code>和<code>send()</code>相关方法最终都会调用<code>enqueueMessage()</code>：</p>
<pre><code>private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) {
    msg.target = this;
    msg.workSourceUid = ThreadLocalWorkSource.getUid();

    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<ul>
<li><code>queue</code>是Handler中的全局变量mQueue实例</li>
<li><code>msg</code>是被发送的消息实例，<code>uptimeMillis</code>是延时的毫秒值</li>
<li><code>msg.target</code>是处理这个Message的Handler</li>
</ul>
<p>调用<code>queue.enqueueMessage</code>把Message提交给MessageQueue，入队和出队操作在MessageQueue中进行。</p>
<p>最后总结一下Handler：Handler用于发送和处理消息，Handler把Message转发给MessageQueue进行入队操作；它持有Looper和MessageQueue的实例，Handler唯一对应了一个Looper和MessageQueue，Looper属于哪个线程，Handler就属于哪个线程。</p>
<h2 id="message">Message</h2>
<p>Message是线程间传递的介质，它包含消息内容和类型；它是一个简单的链表结构，只包含<code>next</code>节点，pop和push都是由MessageQueue完成的。</p>
<pre><code>public final class Message implements Parcelable {
    public int what;
    public int arg1;
    public int arg2;
    public Object obj;
    Bundle data;
    Handler target;
    Runnable callback;

    // sometimes we store linked lists of these things
    Message next;
}
</code></pre>
<ul>
<li><code>what</code>是消息类型</li>
<li><code>arg1</code>、<code>arg2</code>、<code>data</code>、<code>obj</code>用来存放消息内容</li>
<li><code>target</code>是处理Message的Handler引用</li>
<li><code>callback</code>是Runnable类型，如果Handler使用了<code>post(Runnable)</code>系列方法，Runnable在入队之前会被包装成Message，<code>callback</code>就是Runnable的引用</li>
<li><code>next</code>是下一个Message节点的引用，如果一个Handler发送了多个消息MessageQueue里面持有的是Message链表的头节点</li>
</ul>
<p>Message里面有若干个静态的重载<code>obtain()</code>，它们都是用来创建Message的。</p>
<p>::官方文档为什么推荐使用Message.obtain()创建Message？::<br>
这个问题在<code>obtain()</code>的注释里面说的很清楚：</p>
<pre><code>/**
 * Return a new Message instance from the global pool. Allows us to
 * avoid allocating new objects in many cases.
 */
public static Message obtain() {
}
</code></pre>
<p>应用中有全局的Message实例池，创建Message时调用<code>obtain()</code>会从池里面获取Message实例，用完后通过Message的<code>recycler()</code>回收到池中，从而避免了分配过多的Message而占用内存。和线程池的道理是一样的，都是为了促进资源回收和充分利用，避免应用占用过多的内存资源。</p>
<blockquote>
<p>Message的回收是MessageQueue操作的，无需开发者参与</p>
</blockquote>
<h2 id="messagequeue">MessageQueue</h2>
<p>Queue是队列，MessageQueue就是消息队列。MessageQueue中有<code>enqueueMessage()</code>和<code>next()</code>两个方法，分别对应入队和出队操作。Handler通过<code>enqueueMessage()</code>把Message放进消息队列；Looper通过<code>next()</code>获取需要被处理的Message。</p>
<p>Queue，队列像是个传送带；先放上传送带的货物先出去，后放上去的后出去。MessageQueue 的出队顺序并没有遵循入队顺序，而是依据延迟的时间；先到时间的先出去，后到时间的后出去；而延迟时间相同的Message是依据入队顺序出队的。</p>
<h2 id="looper">Looper</h2>
<p>Looper通过名称就可以看出来它的作用是循环获取消息。Looper持有Thread和MessageQueue的引用， Thread是Looper所在的线程，MessageQueue是消息队列。启动Looper只能通过<code>Looper.prepare()</code>：</p>
<pre><code>public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(“Only one Looper may be created per thread”);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre>
<p>Looper中的Thread是获取了当前线程的引用，MessageQueue是new出来的。同一个线程只能调用一次<code>Looper.prepare()</code>，多于一次就会抛出运行时异常。<code>sThreadLocal</code>是线程局部变量，结构类似Map，以键值对的形式存储和当前线程相关的变量。</p>
<p>Looper中最核心的是<code>loop()</code>：</p>
<pre><code>public static void loop() {
    final Looper me = myLooper();                // 1
    if (me == null) {
        throw new RuntimeException(“No Looper; Looper.prepare() wasn’t called on this thread.”);
    }
    final MessageQueue queue = me.mQueue;       // 2

    for (;;) {
        Message msg = queue.next();             // 3
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        try {
            msg.target.dispatchMessage(msg);   // 4
        } catch (Exception exception) {
            throw exception;
        } finally {
            ......
        }
    	  ......
    }
}
</code></pre>
<p>上面的代码是极简版本，省略了很多。</p>
<ol>
<li>获取当前线程的Looper，通过ThreadLocal存储Thread对象和对应的Looper，获取的时候是根据当前线程获取的</li>
<li>获取到当前线程的MessageQueue</li>
<li>获取MessageQueue中的Message，如果Message为null，就返回，开启下次循环</li>
<li>调用Message的target.dispatchMessage(msg)，把Message交给这个Handler</li>
</ol>
<p>现在来到了消息分发的最后一公里，Handler发送的消息，最后还是要交给Handler处理，解铃还须系铃人。</p>
<pre><code>public void dispatchMessage(@NonNull Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
</code></pre>
<p><code>msg.callback</code>是什么？使用<code>handler.post()</code>发送Runnable，在入队之前Runnable会被包装成Message，它会赋值给<code>msg.callback</code>；如果使用了<code>post()</code>系列方法，<code>msg.callback</code>一定不会为空，从而会触发<code>handleCallback(msg)</code>：</p>
<pre><code>private static void handleCallback(Message message) {
    message.callback.run();
}
</code></pre>
<p>如果使用<code>handler.send()</code>发送Message，会走<code>else</code>；<code>mCallback</code>是创建Handler传给构造函数的<code>Callback</code>回调，然后触发<code>handleMessage(msg)</code>。我的快递到了。</p>
<h2 id="总结">总结</h2>
<p>Handler的整体流程就已经很清晰了：</p>
<ol>
<li>主线程通过<code>Handler(Callback)</code>创建Handler，在Callback中处理消息</li>
<li>调用<code>handler.post(Runnable)</code>或者<code>handler.send()</code>发送消息，Runnable会被包装成Message发送出去</li>
<li>在Handler中，通过<code>queue.enqueueMessage()</code>把Message交给MessageQueue进行入队操作</li>
<li>Looper持有MessageQueue的引用，Looper一直在等待MessageQueue中的新消息，一旦获取到新消息，Looper取出Message中的target，调用<code>target.dispatchMessage()</code>，消息最后被分发给Handler的Callback，整个流程就走完了</li>
</ol>
<p>现在再看文章最开始的例子，应该能理解Handler的精髓了。再上一张图：</p>
<h2 id="内存泄漏">内存泄漏</h2>
<p>最后再想一个问题，Handler怎么造成内存泄露的，以及如何避免。</p>
<p>什么是内存泄漏？<br>
给对象分配内存空间后，不再使用该对象时，GC也无法释放它占用的空间。比如，在Android中，结束掉Activity后，Activity占用的内存空间没有被释放，这时Activity就发生了内存泄漏。</p>
<p>Handler发生内存泄漏的代码通常如图所示：<br>
[image:B71C376B-2D54-4E29-8DDE-520E0DFD053E-720-000131948978DBD6/35FE30F1-3604-45F2-9248-D9E8704A3CE3.png]<br>
编译器的提示很委婉：<code>leaks might occur</code>，可能会发生泄漏；所以使用内部类形式的Handler并不一定会发生内存泄漏。</p>
<p>匿名内部类Handler持有Activity的引用，Message持有Handler的引用，MessageQueue持有Message的引用，Looper持有MessageQueue的引用：<code>Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity</code>。主线程的Looper和应用的生命周期是相同的，如果Activity被<code>finish()</code>了，但Handler发送的消息还没有被处理，这时Activity是不会被JVM判定为可以回收的。</p>
<p>由此可以判断，Handler引发的内存泄漏是因为在Activity <code>finish()</code>之前调用了<code>handler.postDelay()</code>或者<code>handler.sendMessageDelay()</code>，在Activity被finish()后Handler还有未处理的消息导致的。</p>
<h3 id="影响几何">影响几何</h3>
<p>由于上述原因导致的内存泄漏会带来什么样的影响？被泄漏的Activity一直都不会被回收吗？</p>
<p>JVM操作内存的垃圾回收，GC会一遍又一遍的、周而复始的扫描内存中存活的对象，如果该对象符合回收条件，就会被回收。</p>
<blockquote>
<p>JVM有若干GC算法，比如，标记-清除、标记-复制、可达性分析等。像标记-清除，它分为两个阶段，先标记可回收的对象，等下次GC发生时清除被标记的对象。</p>
</blockquote>
<p>假如Activity <code>finish()</code>之前调用了<code>handler.postDelay({ //若干操作 }, 5000)</code>，触发了5秒后的延时操作。在这5秒内GC可能对该Activity扫描了一次，也可能扫描了多次，每次扫描Activity GC都发现有引用指向它，所以肯定不会回收它；到第5秒，Runnable被Handler处理了，指向该Activity的Message也被回收，下次GC再次扫描Activity发现没有引用指向它，此时Activity即将被回收。</p>
<p>由此可以得出结论：由于Handler发送延迟消息导致的Activity内存泄漏，会在延迟消息被处理后，Activity才会被GC回收。Activity泄漏的时间长短取决于Handler发送的延迟消息的延迟时间。</p>
<h3 id="解决内存泄漏">解决内存泄漏</h3>
<p>明确了Handler是怎么导致内存泄漏的，解决方案也很容易：</p>
<ol>
<li>Handler由内部类的形式改成静态内部类的形式，因为静态内部类不持有外部类的引用；Handler不持有Activity的引用，即便有延迟消息也不会发生内存泄漏</li>
<li>在Activity <code>finish()</code>之前调用<code>handler.removeCallbacksAndMessages(null)</code>，移除Handler中所有未处理的任务，这样也就避免了内存泄漏<br>
具体使用什么样的策略取决于代码的业务场景。</li>
</ol>
<p>这篇文章到此就结束了。本文介绍了Handler的工作流程，并分析了常见的几个Handler相关的面试问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>http://localhost:4000/post/hello-gridea</id>
        <link href="http://localhost:4000/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>