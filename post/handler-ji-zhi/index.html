<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Handler | Yt100</title>

<link rel="shortcut icon" href="https://wanyt.github.io/favicon.ico?v=1597373965737">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://wanyt.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Yt100
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1597373965737" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Handler
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2019-10-27 ·
                    </time>
                    
                        <a href="https://wanyt.github.io/tag/vBeuSX4CE/" class="post-tags">
                            # Handler
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>想象这样一个场景：我在淘宝下个订单，订单上包含我的姓名和地址、货物名称等，商家把订单打包后交给顺丰，顺丰把订单运到北京的集散中心，集散中心根据订单上的姓名和地址把货物派送给我。这是网购的流程，和Handler机制有异曲同工之处：</p>
<ol>
<li>我 —— Handler，我下订单就是<code>handler.post()</code>，订单经过转运之后还是交给我；Handler发消息的最终目的地还是Handler的回调处理消息</li>
<li>订单 —— Message，订单里包含收货地址，货物等，就是<code>msg.target</code>、<code>msg.what</code>、<code>msg.data</code>，Message是消息传递的介质</li>
<li>顺丰 —— MessageQueue，这个很好理解，MessageQueue就是搬运工，根据消息的时间先后顺序分发消息</li>
<li>集散中心 —— Looper，集散中心一直阻塞在这里等待新的货物到达，然后根据订单上的地址分发快递；Looper在for循环里一直获取最新的消息，如果有新消息就根据<code>msg.target</code>获取到handler然后调用<code>dispatchMessage()</code>把消息分发下去，最后触发Handler的Callback回调</li>
</ol>
<p>虽然这个例子并没有完美的契合Handler的运行机制（还有商家没有对应到Handler），但是对于理解Handler是十分有帮助的。</p>
<p>Handler是Android <mark>应用</mark> 层中广泛使用的多线程通信组件。Handler的用途表现在两个方面：（1）延时执行Runnable或延时发送Message；（2）线程间通信，给其他线程发消息，通知其他线程执行操作。</p>
<p>整个Handler机制包含四个角色：</p>
<ul>
<li><code>Handler</code>，它是开发者直接操作的对象，它参与了消息分发流程中发送和处理消息的过程</li>
<li><code>Message</code>，是消息传递的介质，传递的数据要包装成Message</li>
<li><code>MessageQueue</code>，开发者几乎无法接触，它操作了消息的入队和出队</li>
<li><code>Looper</code>，消息分发的核心，整个流程的心脏</li>
</ul>
<p>Android面试经常会问Handler，虽然这是一个老生常谈的话题，但真正搞明白还是要花费一番功夫，比如：</p>
<ol>
<li>Handler的运行机制是什么样的？</li>
<li>子线程中可以直接创建Handler吗？</li>
<li>官方文档为什么推荐使用Message.obtain()创建Message？</li>
<li>Handler是怎么造成内存泄漏的？在Activity中创建Handler成员变量一定会造成内存泄漏吗？</li>
</ol>
<p>本文会一一解答上面的问题。现在先依次介绍Handler的四个角色，介绍完Handler的整个运行机制就会很清晰。</p>
<h2 id="handler">Handler</h2>
<p>Handler负责发送和处理Message。在哪个线程创建Handler，它就属于哪个线程；比如，在Activity中创建Handler实例，那么这个Handler就和主线程绑定了。当然，在Activity中创建Handler的匿名内部类变量可能会造成内存泄漏</p>
<p>通过方法名和参数可以把Handler的发送操作分为两个系列：</p>
<ol>
<li><code>post()</code>系列方法，它是用来发送Runnable对象到MessageQueue中。如，<code>post(Runnable r)</code>、<code>postAtTime(Runnable r, long uptimeMillis)</code>、<code>postDelayed(Runnable r, long delayMillis)</code>等</li>
<li><code>send()</code>系列方法，它是用来发送Message对象到MessageQueue中。如，<code>sendMessage(Message msg)</code>、<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>、<code>sendMessageDelayed(Message msg, long delayMillis)</code>等<br>
这两个系列的方法分别用来发送和处理Runnable和Message对象；Runnable在Handler中也会被包装成Message发送给MessageQueue。</li>
</ol>
<h3 id="创建">创建</h3>
<p>Handler提供了多个构造函数，创建Handler最常用的构造函数是：</p>
<pre><code>public Handler(@Nullable Callback callback) {
    this(callback, false);
}

public Handler(@Nullable Callback callback, boolean async) {
    …省略代码…
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            “Can’t create handler inside thread “ + Thread.currentThread()
                    + “ that has not called Looper.prepare()”);
    }
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
</code></pre>
<p>在构造函数中，Handler获取了mLooper和mQueue的实例。这也说明了，Handler和Looper绑定，Handler唯一对应一个Looper，Looper运行在哪个线程Handler就属于哪个线程。</p>
<p>::子线程中可以直接创建Handler吗？::<br>
”不可以，会抛出运行时异常，需要先调用<code>Looper.prepare()</code>。”当然，这是一个正确但不严谨的回答。</p>
<pre><code>	val runnable = Runnable {  Handler()  }
  Thread(runnable).start()
</code></pre>
<p>运行上面的代码会报错：<code>java.lang.RuntimeException: Can't create handler inside thread Thread[Thread-2,5,main] that has not called Looper.prepare()</code>。子线程没有运行Looper。</p>
<p>确定不可以在子线程直接创建Handler吗？当然可以。Handler提供了下面的构造函数：</p>
<pre><code>public Handler(@NonNull Looper looper, @Nullable Callback callback) {
    this(looper, callback, false);
}
</code></pre>
<p>给Handler的构造函数传Looper，Handler会绑定到Looper运行的线程：</p>
<pre><code>val runnable = Runnable {
		val handler = Handler(Looper.getMainLooper())
		handler.post { //更新UI }
}
Thread(runnable).start()
</code></pre>
<p>通过这种方式创建的<code>handler</code>运行在主线程，<code>handler.post(Runnable)</code>就可以在该Runnable中直接对UI进行更新。</p>
<p>子线程创建Handler的另一个更通用的方法是调用<code>Looper.prepare()</code>，先让子线程运行Looper：</p>
<pre><code>	val runnable = Runnable {
		Looper.prepare()
		Looper.loop()
      val rHandler = Handler()
  }
  Thread(runnable).start()
</code></pre>
<p><code>rHandler</code>是子线程的Handler()，其他线程获取到<code>rHandler</code>就可以给它发送Message和Runnable，实现线程间通信。</p>
<p>回到上面的问题，::子线程中可以直接创建Handler吗？:: 子线程创建Handler有两种方式：</p>
<ol>
<li>最常用的方式是先调用<code>Looper.prepare()</code>和<code>Looper.loop()</code>让子线程运行Looper，然后再创建Handler；如果子线程已经运行了Looper，那就可以直接创建Handler。通过这种方式创建的Handler是运行在子线程的。</li>
<li>可以通过<code>Handler(Looper looper)</code>在子线程创建Handler。通过这种方式创建的Handler和参数中looper运行在同一个线程；比如，在子线程中调用<code>Handler(Looper.getMainLooper())</code>，创建的Handler是运行在主线程的。</li>
</ol>
<h3 id="消息入队">消息入队</h3>
<p><code>post()</code>系列方法会先调用<code>getPostMessage(Runnable r)</code>把Runnable包装成Message，然后再进行入队操作：</p>
<pre><code>public final boolean post(@NonNull Runnable r) {
   return  sendMessageDelayed(getPostMessage(r), 0);
}

public final boolean postAtTime(@NonNull Runnable r, long uptimeMillis) {
    return sendMessageAtTime(getPostMessage(r), uptimeMillis);
}

public final boolean postDelayed(@NonNull Runnable r, long delayMillis) {
    return sendMessageDelayed(getPostMessage(r), delayMillis);
}

private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
</code></pre>
<p><code>post()</code>和<code>send()</code>相关方法最终都会调用<code>enqueueMessage()</code>：</p>
<pre><code>private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) {
    msg.target = this;
    msg.workSourceUid = ThreadLocalWorkSource.getUid();

    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<ul>
<li><code>queue</code>是Handler中的全局变量mQueue实例</li>
<li><code>msg</code>是被发送的消息实例，<code>uptimeMillis</code>是延时的毫秒值</li>
<li><code>msg.target</code>是处理这个Message的Handler</li>
</ul>
<p>调用<code>queue.enqueueMessage</code>把Message提交给MessageQueue，入队和出队操作在MessageQueue中进行。</p>
<p>最后总结一下Handler：Handler用于发送和处理消息，Handler把Message转发给MessageQueue进行入队操作；它持有Looper和MessageQueue的实例，Handler唯一对应了一个Looper和MessageQueue，Looper属于哪个线程，Handler就属于哪个线程。</p>
<h2 id="message">Message</h2>
<p>Message是线程间传递的介质，它包含消息内容和类型；它是一个简单的链表结构，只包含<code>next</code>节点，pop和push都是由MessageQueue完成的。</p>
<pre><code>public final class Message implements Parcelable {
    public int what;
    public int arg1;
    public int arg2;
    public Object obj;
    Bundle data;
    Handler target;
    Runnable callback;

    // sometimes we store linked lists of these things
    Message next;
}
</code></pre>
<ul>
<li><code>what</code>是消息类型</li>
<li><code>arg1</code>、<code>arg2</code>、<code>data</code>、<code>obj</code>用来存放消息内容</li>
<li><code>target</code>是处理Message的Handler引用</li>
<li><code>callback</code>是Runnable类型，如果Handler使用了<code>post(Runnable)</code>系列方法，Runnable在入队之前会被包装成Message，<code>callback</code>就是Runnable的引用</li>
<li><code>next</code>是下一个Message节点的引用，如果一个Handler发送了多个消息MessageQueue里面持有的是Message链表的头节点</li>
</ul>
<p>Message里面有若干个静态的重载<code>obtain()</code>，它们都是用来创建Message的。</p>
<p>::官方文档为什么推荐使用Message.obtain()创建Message？::<br>
这个问题在<code>obtain()</code>的注释里面说的很清楚：</p>
<pre><code>/**
 * Return a new Message instance from the global pool. Allows us to
 * avoid allocating new objects in many cases.
 */
public static Message obtain() {
}
</code></pre>
<p>应用中有全局的Message实例池，创建Message时调用<code>obtain()</code>会从池里面获取Message实例，用完后通过Message的<code>recycler()</code>回收到池中，从而避免了分配过多的Message而占用内存。和线程池的道理是一样的，都是为了促进资源回收和充分利用，避免应用占用过多的内存资源。</p>
<blockquote>
<p>Message的回收是MessageQueue操作的，无需开发者参与</p>
</blockquote>
<h2 id="messagequeue">MessageQueue</h2>
<p>Queue是队列，MessageQueue就是消息队列。MessageQueue中有<code>enqueueMessage()</code>和<code>next()</code>两个方法，分别对应入队和出队操作。Handler通过<code>enqueueMessage()</code>把Message放进消息队列；Looper通过<code>next()</code>获取需要被处理的Message。</p>
<p>Queue，队列像是个传送带；先放上传送带的货物先出去，后放上去的后出去。MessageQueue 的出队顺序并没有遵循入队顺序，而是依据延迟的时间；先到时间的先出去，后到时间的后出去；而延迟时间相同的Message是依据入队顺序出队的。</p>
<h2 id="looper">Looper</h2>
<p>Looper通过名称就可以看出来它的作用是循环获取消息。Looper持有Thread和MessageQueue的引用， Thread是Looper所在的线程，MessageQueue是消息队列。启动Looper只能通过<code>Looper.prepare()</code>：</p>
<pre><code>public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(“Only one Looper may be created per thread”);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
}
</code></pre>
<p>Looper中的Thread是获取了当前线程的引用，MessageQueue是new出来的。同一个线程只能调用一次<code>Looper.prepare()</code>，多于一次就会抛出运行时异常。<code>sThreadLocal</code>是线程局部变量，结构类似Map，以键值对的形式存储和当前线程相关的变量。</p>
<p>Looper中最核心的是<code>loop()</code>：</p>
<pre><code>public static void loop() {
    final Looper me = myLooper();                // 1
    if (me == null) {
        throw new RuntimeException(“No Looper; Looper.prepare() wasn’t called on this thread.”);
    }
    final MessageQueue queue = me.mQueue;       // 2

    for (;;) {
        Message msg = queue.next();             // 3
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        try {
            msg.target.dispatchMessage(msg);   // 4
        } catch (Exception exception) {
            throw exception;
        } finally {
            ......
        }
    	  ......
    }
}
</code></pre>
<p>上面的代码是极简版本，省略了很多。</p>
<ol>
<li>获取当前线程的Looper，通过ThreadLocal存储Thread对象和对应的Looper，获取的时候是根据当前线程获取的</li>
<li>获取到当前线程的MessageQueue</li>
<li>获取MessageQueue中的Message，如果Message为null，就返回，开启下次循环</li>
<li>调用Message的target.dispatchMessage(msg)，把Message交给这个Handler</li>
</ol>
<p>现在来到了消息分发的最后一公里，Handler发送的消息，最后还是要交给Handler处理，解铃还须系铃人。</p>
<pre><code>public void dispatchMessage(@NonNull Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
</code></pre>
<p><code>msg.callback</code>是什么？使用<code>handler.post()</code>发送Runnable，在入队之前Runnable会被包装成Message，它会赋值给<code>msg.callback</code>；如果使用了<code>post()</code>系列方法，<code>msg.callback</code>一定不会为空，从而会触发<code>handleCallback(msg)</code>：</p>
<pre><code>private static void handleCallback(Message message) {
    message.callback.run();
}
</code></pre>
<p>如果使用<code>handler.send()</code>发送Message，会走<code>else</code>；<code>mCallback</code>是创建Handler传给构造函数的<code>Callback</code>回调，然后触发<code>handleMessage(msg)</code>。我的快递到了。</p>
<h2 id="总结">总结</h2>
<p>Handler的整体流程就已经很清晰了：</p>
<ol>
<li>主线程通过<code>Handler(Callback)</code>创建Handler，在Callback中处理消息</li>
<li>调用<code>handler.post(Runnable)</code>或者<code>handler.send()</code>发送消息，Runnable会被包装成Message发送出去</li>
<li>在Handler中，通过<code>queue.enqueueMessage()</code>把Message交给MessageQueue进行入队操作</li>
<li>Looper持有MessageQueue的引用，Looper一直在等待MessageQueue中的新消息，一旦获取到新消息，Looper取出Message中的target，调用<code>target.dispatchMessage()</code>，消息最后被分发给Handler的Callback，整个流程就走完了</li>
</ol>
<p>现在再看文章最开始的例子，应该能理解Handler的精髓了。再上一张图：</p>
<h2 id="内存泄漏">内存泄漏</h2>
<p>最后再想一个问题，Handler怎么造成内存泄露的，以及如何避免。</p>
<p>什么是内存泄漏？<br>
给对象分配内存空间后，不再使用该对象时，GC也无法释放它占用的空间。比如，在Android中，结束掉Activity后，Activity占用的内存空间没有被释放，这时Activity就发生了内存泄漏。</p>
<p>Handler发生内存泄漏的代码通常如图所示：<br>
<img src="https://wanyt.github.io/post-images/1574240208503.png" alt="" loading="lazy"><br>
编译器的提示很委婉：<code>leaks might occur</code>，可能会发生泄漏；所以使用内部类形式的Handler并不一定会发生内存泄漏。</p>
<p>匿名内部类Handler持有Activity的引用，Message持有Handler的引用，MessageQueue持有Message的引用，Looper持有MessageQueue的引用：<code>Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity</code>。主线程的Looper和应用的生命周期是相同的，如果Activity被<code>finish()</code>了，但Handler发送的消息还没有被处理，这时Activity是不会被JVM判定为可以回收的。</p>
<p>由此可以判断，Handler引发的内存泄漏是因为在Activity <code>finish()</code>之前调用了<code>handler.postDelay()</code>或者<code>handler.sendMessageDelay()</code>，在Activity被finish()后Handler还有未处理的消息导致的。</p>
<h3 id="影响几何">影响几何</h3>
<p>由于上述原因导致的内存泄漏会带来什么样的影响？被泄漏的Activity一直都不会被回收吗？</p>
<p>JVM操作内存的垃圾回收，GC会一遍又一遍的、周而复始的扫描内存中存活的对象，如果该对象符合回收条件，就会被回收。</p>
<blockquote>
<p>JVM有若干GC算法，比如，标记-清除、标记-复制、可达性分析等。像标记-清除，它分为两个阶段，先标记可回收的对象，等下次GC发生时清除被标记的对象。</p>
</blockquote>
<p>假如Activity <code>finish()</code>之前调用了<code>handler.postDelay({ //若干操作 }, 5000)</code>，触发了5秒后的延时操作。在这5秒内GC可能对该Activity扫描了一次，也可能扫描了多次，每次扫描Activity GC都发现有引用指向它，所以肯定不会回收它；到第5秒，Runnable被Handler处理了，指向该Activity的Message也被回收，下次GC再次扫描Activity发现没有引用指向它，此时Activity即将被回收。</p>
<p>由此可以得出结论：由于Handler发送延迟消息导致的Activity内存泄漏，会在延迟消息被处理后，Activity才会被GC回收。Activity泄漏的时间长短取决于Handler发送的延迟消息的延迟时间。</p>
<h3 id="解决内存泄漏">解决内存泄漏</h3>
<p>明确了Handler是怎么导致内存泄漏的，解决方案也很容易：</p>
<ol>
<li>Handler由内部类的形式改成静态内部类的形式，因为静态内部类不持有外部类的引用；Handler不持有Activity的引用，即便有延迟消息也不会发生内存泄漏</li>
<li>在Activity <code>finish()</code>之前调用<code>handler.removeCallbacksAndMessages(null)</code>，移除Handler中所有未处理的任务，这样也就避免了内存泄漏<br>
具体使用什么样的策略取决于代码的业务场景。</li>
</ol>
<p>这篇文章到此就结束了。本文介绍了Handler的工作流程，并分析了常见的几个Handler相关的面试问题。</p>

                </div>
            </article>
        </div>

        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">实践出真知</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://wanyt.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
