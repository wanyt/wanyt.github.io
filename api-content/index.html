{"posts":[{"title":"ThreadLocalMap","content":"线性探测法解决哈希冲突的典型实现 既然是Map那么它就是用来存储键值对的的数据结构。Java中常用的Map有HashMap、HashTable、ConcurrentHashMap等。ThreadLocalMap并没有实现Map接口，它不属于Java的集合体系，它是包级别可见，没有对开发者开放，仅供ThreadLocal和Thread使用。 HashMap使用拉链法解决哈希冲突；ThreadLocalMap和HashTable一样使用线性探测法解决哈希冲突。 为什么使用WeakReference? private void set(ThreadLocal&lt;?&gt; key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; // 如果e有值，则进入循环；如果e为null，则退出循环 e = tab[i = nextIndex(i, len)]) { // 循环体执行完成后，执行本语句；执行本语句的前提是：i-1有值 ThreadLocal&lt;?&gt; k = e.get(); if (k == key) { // 找到了相同的key，则新值覆盖旧值，然后返回 e.value = value; return; } if (k == null) { // Entry不为空，但key为null，代表key已被GC回收 replaceStaleEntry(key, value, i); return; } } // 执行到此代表哈希后的数组索引处没有Entry，可直接将key-value存储至该索引处 tab[i] = new Entry(key, value); int sz = ++size; // 容量+1 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) // 如果数组中不需要清除已被回收的元素，并且容量已达扩容的阈值，则对数组进行扩容 rehash(); } private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,int staleSlot) { Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; //从staleSlot开始向上遍历 for (int i = prevIndex(staleSlot, len); //获取当前位置的前一个位置作为初始索引 (e = tab[i]) != null; // 如果entry有值，进入循环体，如果为null则退出循环 i = prevIndex(i, len)) // 获取前一个索引的值 if (e.get() == null) // 循环体，如果Entry不为null且key为null，则代表key已被GC回收，该索引处的Entry可被销毁 slotToExpunge = i; //记录可以被销毁的索引 //从staleSlot开始向下遍历 for (int i = nextIndex(staleSlot, len); //获取当前位置的下一个索引作为初始值 (e = tab[i]) != null; //如果entry有值，进入循环体，如果为null则退出循环 i = nextIndex(i, len)) { //获取下一个索引 ThreadLocal&lt;?&gt; k = e.get(); if (k == key) { //如果索引处的Entry.key和方法参数中的key相等 e.value = value;//新值覆盖旧值 tab[i] = tab[staleSlot]; //!!!!!!!此处代码意图还不是太明晰!!!!!!! tab[staleSlot] = e; if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; } if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; } tab[staleSlot].value = null; //标记旧的Entry可被GC回收 tab[staleSlot] = new Entry(key, value); //记录新的Entry if (slotToExpunge != staleSlot) // 如果slotToExpunge和staleSlot的值不相等，则代表哈希表中有需要被销毁的Entry，此时需要做清理Entry的操作 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); } private boolean cleanSomeSlots(int i, int n) { boolean removed = false; // 是否有被移除的Entry Entry[] tab = table; int len = tab.length; // 先执行do，然后执行while，满足条件再执行do；如此往复 do { i = nextIndex(i, len); //获取下一个索引 Entry e = tab[i]; //获取下一个索引处的Entry if (e != null &amp;&amp; e.get() == null) { // 如果Entry不为null,但key为null,则该Entry可被销毁 n = len; // 控制遍历次数 removed = true; i = expungeStaleEntry(i); //删除该处索引的Entry } } while ( (n &gt;&gt;&gt;= 1) != 0); //每次n右移1位则等同于n除以2，！！为什么这样做有待考证！！ return removed; } i：一个已知的可用的Entry索引，从i+1处开始扫描 private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; tab[staleSlot].value = null; tab[staleSlot] = null; //把索引处的Entry置为null size--; // size减1 // 从staleSlot+1开始向下遍历, // 如果发现有Entry.key为null, 则将该Entry置为null // 如果Entry不为null, 则使用哈希值对其重新映射 Entry e; int i; for (i = nextIndex(staleSlot, len); // 从staleSlot+1开始 (e = tab[i]) != null; // Entry有值进入循环, 否则退出循环 i = nextIndex(i, len)) { // 获取下一个索引, 向下遍历 ThreadLocal&lt;?&gt; k = e.get(); if (k == null) { // 如果key为null将Entry置为null e.value = null; tab[i] = null; size--; } else { // 如果key不为null, 对Entry rehash int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) { tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); // 线性探测解决哈希冲突 tab[h] = e; } } } return i; } ","link":"https://wanyt.github.io/post/threadlocalmap/"},{"title":"选择排序","content":"为什么叫选择排序呢？当然是和它的实现过程有关。首先，选择数组中最小的元素，把它和数组的第一个元素交换位置；然后，在数组的剩余元素中选择最小元素，把它和数组的第二个元素交换位置。如此循环往复，直到最后一个元素。 下图是选择排序的过程图： 初始顺序是：5，3，8，7，9，6，0，2 红色字体代表未排序的元素 白色字体代表排序完成和已知最小值的元素 蓝色背景代表两个元素相比较 黄色背景代表两个元素需要交换位置 代码实现 public int[] sort(int[] arr) { for(int i = 0; i &lt; arr.length; i++){ int minIndex = i; //最小元素的索引 for (int j = i + 1; j &lt; arr.length; j++){ if(arr[j] &lt; arr[minIndex]){ minIndex = j; } } exch(arr, i, minIndex); } return arr; } 通过两个for循环实现选择排序。外层循环负责记录当前需要被排序元素的索引；内层for循环负责寻找数组中剩余未排序元素中最小的元素，记录它的索引，然后使用exch()交换两个元素的位置，再开始下一个元素的排序循环。 复杂度分析 在排序的过程中主要做了什么事情呢？有两件，一是外循环的交换，另一个是内循环的比较。问，交换和比较的次数分别是多少？ 交换比较直观，exch()在外层for循环中，所以，外层for循环执行了多少次exch()就执行了多少了，exch()的执行次数就是交换的次数，所以，最坏情况下交换了_N次_。 为什么说最坏情况交换了N次呢？在exch()中要有个判断if (i &lt; minIndex)才会执行交换。否则就代表i索引处的元素就已经是最小元素了。因此，交换次数只可能小于等于N。 现在再分析比较的次数。用代码分析太抽象，举个例子，现有数组[5,4,3,2,1]，给该数组使用选择排序的比较过程如下： 给5个元素的数组排序，需要循环4轮，每轮又需要若干次比较，蓝色的勾是比较的次数。第一轮需要比较4次，第二轮比较3次，第三轮比较2次，第四轮比较1次。这里有个规律，总次数 = (5-1) + (5-2) + (5-3) + (5-4)；类推可得，给长度为N的数组使用选择排序，总比较次数为： 总次数 = (N-1) + (N-2) + ... + 2 + 1 等式右边的是个等差数列，公差是1。等差数列的前N项和是：Sn=n(a1+an)/2。带入公式可得： 总次数 = (n² - n) / 2 把5代入到上式可得：给长度为5的数组进行选择排序，需要比较的次数是10。这个结果跟上面计算出来的结果是一样的。 通过以上的分析可得出如下结论，对N个元素使用选择排序： 最坏情况需要交换N次 一定需要(n² - n) / 2次比较 所以，选择排序的时间复杂度取决于比较的次数。 优劣分析 再看上面的例子，给数组[5, 4, 3, 2, 1]排序，当进行到第三轮循环数组就已经是有序的，但循环还要继续，依然要进行后续的比较。假如对有序数组[1, 2, 3, 4, 5, ... 9999, 10000]使用选择排序，会发现它和有10000个元素的无序数组的运行时间是相同的，这个效率令人大跌眼镜。数组的初始顺序对运行时间没有任何影响，对部分有序数组使用选择排序绝对不是明智的选择。 但选择排序的数据移动是最少的。每次交换都会改变两个数组元素的值，可以确定一个元素的位置，最多进行N次交换，交换次数和数组大小呈线性关系。 选择排序属于原地排序，不需要申请额外的内存控件，空间复杂度为O(n)。 ","link":"https://wanyt.github.io/post/xuan-ze-pai-xu/"},{"title":"Handler","content":"想象这样一个场景：我在淘宝下个订单，订单上包含我的姓名和地址、货物名称等，商家把订单打包后交给顺丰，顺丰把订单运到北京的集散中心，集散中心根据订单上的姓名和地址把货物派送给我。这是网购的流程，和Handler机制有异曲同工之处： 我 —— Handler，我下订单就是handler.post()，订单经过转运之后还是交给我；Handler发消息的最终目的地还是Handler的回调处理消息 订单 —— Message，订单里包含收货地址，货物等，就是msg.target、msg.what、msg.data，Message是消息传递的介质 顺丰 —— MessageQueue，这个很好理解，MessageQueue就是搬运工，根据消息的时间先后顺序分发消息 集散中心 —— Looper，集散中心一直阻塞在这里等待新的货物到达，然后根据订单上的地址分发快递；Looper在for循环里一直获取最新的消息，如果有新消息就根据msg.target获取到handler然后调用dispatchMessage()把消息分发下去，最后触发Handler的Callback回调 虽然这个例子并没有完美的契合Handler的运行机制（还有商家没有对应到Handler），但是对于理解Handler是十分有帮助的。 Handler是Android 应用 层中广泛使用的多线程通信组件。Handler的用途表现在两个方面：（1）延时执行Runnable或延时发送Message；（2）线程间通信，给其他线程发消息，通知其他线程执行操作。 整个Handler机制包含四个角色： Handler，它是开发者直接操作的对象，它参与了消息分发流程中发送和处理消息的过程 Message，是消息传递的介质，传递的数据要包装成Message MessageQueue，开发者几乎无法接触，它操作了消息的入队和出队 Looper，消息分发的核心，整个流程的心脏 Android面试经常会问Handler，虽然这是一个老生常谈的话题，但真正搞明白还是要花费一番功夫，比如： Handler的运行机制是什么样的？ 子线程中可以直接创建Handler吗？ 官方文档为什么推荐使用Message.obtain()创建Message？ Handler是怎么造成内存泄漏的？在Activity中创建Handler成员变量一定会造成内存泄漏吗？ 本文会一一解答上面的问题。现在先依次介绍Handler的四个角色，介绍完Handler的整个运行机制就会很清晰。 Handler Handler负责发送和处理Message。在哪个线程创建Handler，它就属于哪个线程；比如，在Activity中创建Handler实例，那么这个Handler就和主线程绑定了。当然，在Activity中创建Handler的匿名内部类变量可能会造成内存泄漏 通过方法名和参数可以把Handler的发送操作分为两个系列： post()系列方法，它是用来发送Runnable对象到MessageQueue中。如，post(Runnable r)、postAtTime(Runnable r, long uptimeMillis)、postDelayed(Runnable r, long delayMillis)等 send()系列方法，它是用来发送Message对象到MessageQueue中。如，sendMessage(Message msg)、sendMessageAtTime(Message msg, long uptimeMillis)、sendMessageDelayed(Message msg, long delayMillis)等 这两个系列的方法分别用来发送和处理Runnable和Message对象；Runnable在Handler中也会被包装成Message发送给MessageQueue。 创建 Handler提供了多个构造函数，创建Handler最常用的构造函数是： public Handler(@Nullable Callback callback) { this(callback, false); } public Handler(@Nullable Callback callback, boolean async) { …省略代码… mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( “Can’t create handler inside thread “ + Thread.currentThread() + “ that has not called Looper.prepare()”); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 在构造函数中，Handler获取了mLooper和mQueue的实例。这也说明了，Handler和Looper绑定，Handler唯一对应一个Looper，Looper运行在哪个线程Handler就属于哪个线程。 ::子线程中可以直接创建Handler吗？:: ”不可以，会抛出运行时异常，需要先调用Looper.prepare()。”当然，这是一个正确但不严谨的回答。 val runnable = Runnable { Handler() } Thread(runnable).start() 运行上面的代码会报错：java.lang.RuntimeException: Can't create handler inside thread Thread[Thread-2,5,main] that has not called Looper.prepare()。子线程没有运行Looper。 确定不可以在子线程直接创建Handler吗？当然可以。Handler提供了下面的构造函数： public Handler(@NonNull Looper looper, @Nullable Callback callback) { this(looper, callback, false); } 给Handler的构造函数传Looper，Handler会绑定到Looper运行的线程： val runnable = Runnable { val handler = Handler(Looper.getMainLooper()) handler.post { //更新UI } } Thread(runnable).start() 通过这种方式创建的handler运行在主线程，handler.post(Runnable)就可以在该Runnable中直接对UI进行更新。 子线程创建Handler的另一个更通用的方法是调用Looper.prepare()，先让子线程运行Looper： val runnable = Runnable { Looper.prepare() Looper.loop() val rHandler = Handler() } Thread(runnable).start() rHandler是子线程的Handler()，其他线程获取到rHandler就可以给它发送Message和Runnable，实现线程间通信。 回到上面的问题，::子线程中可以直接创建Handler吗？:: 子线程创建Handler有两种方式： 最常用的方式是先调用Looper.prepare()和Looper.loop()让子线程运行Looper，然后再创建Handler；如果子线程已经运行了Looper，那就可以直接创建Handler。通过这种方式创建的Handler是运行在子线程的。 可以通过Handler(Looper looper)在子线程创建Handler。通过这种方式创建的Handler和参数中looper运行在同一个线程；比如，在子线程中调用Handler(Looper.getMainLooper())，创建的Handler是运行在主线程的。 消息入队 post()系列方法会先调用getPostMessage(Runnable r)把Runnable包装成Message，然后再进行入队操作： public final boolean post(@NonNull Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } public final boolean postAtTime(@NonNull Runnable r, long uptimeMillis) { return sendMessageAtTime(getPostMessage(r), uptimeMillis); } public final boolean postDelayed(@NonNull Runnable r, long delayMillis) { return sendMessageDelayed(getPostMessage(r), delayMillis); } private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m; } post()和send()相关方法最终都会调用enqueueMessage()： private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } queue是Handler中的全局变量mQueue实例 msg是被发送的消息实例，uptimeMillis是延时的毫秒值 msg.target是处理这个Message的Handler 调用queue.enqueueMessage把Message提交给MessageQueue，入队和出队操作在MessageQueue中进行。 最后总结一下Handler：Handler用于发送和处理消息，Handler把Message转发给MessageQueue进行入队操作；它持有Looper和MessageQueue的实例，Handler唯一对应了一个Looper和MessageQueue，Looper属于哪个线程，Handler就属于哪个线程。 Message Message是线程间传递的介质，它包含消息内容和类型；它是一个简单的链表结构，只包含next节点，pop和push都是由MessageQueue完成的。 public final class Message implements Parcelable { public int what; public int arg1; public int arg2; public Object obj; Bundle data; Handler target; Runnable callback; // sometimes we store linked lists of these things Message next; } what是消息类型 arg1、arg2、data、obj用来存放消息内容 target是处理Message的Handler引用 callback是Runnable类型，如果Handler使用了post(Runnable)系列方法，Runnable在入队之前会被包装成Message，callback就是Runnable的引用 next是下一个Message节点的引用，如果一个Handler发送了多个消息MessageQueue里面持有的是Message链表的头节点 Message里面有若干个静态的重载obtain()，它们都是用来创建Message的。 ::官方文档为什么推荐使用Message.obtain()创建Message？:: 这个问题在obtain()的注释里面说的很清楚： /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */ public static Message obtain() { } 应用中有全局的Message实例池，创建Message时调用obtain()会从池里面获取Message实例，用完后通过Message的recycler()回收到池中，从而避免了分配过多的Message而占用内存。和线程池的道理是一样的，都是为了促进资源回收和充分利用，避免应用占用过多的内存资源。 Message的回收是MessageQueue操作的，无需开发者参与 MessageQueue Queue是队列，MessageQueue就是消息队列。MessageQueue中有enqueueMessage()和next()两个方法，分别对应入队和出队操作。Handler通过enqueueMessage()把Message放进消息队列；Looper通过next()获取需要被处理的Message。 Queue，队列像是个传送带；先放上传送带的货物先出去，后放上去的后出去。MessageQueue 的出队顺序并没有遵循入队顺序，而是依据延迟的时间；先到时间的先出去，后到时间的后出去；而延迟时间相同的Message是依据入队顺序出队的。 Looper Looper通过名称就可以看出来它的作用是循环获取消息。Looper持有Thread和MessageQueue的引用， Thread是Looper所在的线程，MessageQueue是消息队列。启动Looper只能通过Looper.prepare()： public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(“Only one Looper may be created per thread”); } sThreadLocal.set(new Looper(quitAllowed)); } private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } Looper中的Thread是获取了当前线程的引用，MessageQueue是new出来的。同一个线程只能调用一次Looper.prepare()，多于一次就会抛出运行时异常。sThreadLocal是线程局部变量，结构类似Map，以键值对的形式存储和当前线程相关的变量。 Looper中最核心的是loop()： public static void loop() { final Looper me = myLooper(); // 1 if (me == null) { throw new RuntimeException(“No Looper; Looper.prepare() wasn’t called on this thread.”); } final MessageQueue queue = me.mQueue; // 2 for (;;) { Message msg = queue.next(); // 3 if (msg == null) { // No message indicates that the message queue is quitting. return; } try { msg.target.dispatchMessage(msg); // 4 } catch (Exception exception) { throw exception; } finally { ...... } ...... } } 上面的代码是极简版本，省略了很多。 获取当前线程的Looper，通过ThreadLocal存储Thread对象和对应的Looper，获取的时候是根据当前线程获取的 获取到当前线程的MessageQueue 获取MessageQueue中的Message，如果Message为null，就返回，开启下次循环 调用Message的target.dispatchMessage(msg)，把Message交给这个Handler 现在来到了消息分发的最后一公里，Handler发送的消息，最后还是要交给Handler处理，解铃还须系铃人。 public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } msg.callback是什么？使用handler.post()发送Runnable，在入队之前Runnable会被包装成Message，它会赋值给msg.callback；如果使用了post()系列方法，msg.callback一定不会为空，从而会触发handleCallback(msg)： private static void handleCallback(Message message) { message.callback.run(); } 如果使用handler.send()发送Message，会走else；mCallback是创建Handler传给构造函数的Callback回调，然后触发handleMessage(msg)。我的快递到了。 总结 Handler的整体流程就已经很清晰了： 主线程通过Handler(Callback)创建Handler，在Callback中处理消息 调用handler.post(Runnable)或者handler.send()发送消息，Runnable会被包装成Message发送出去 在Handler中，通过queue.enqueueMessage()把Message交给MessageQueue进行入队操作 Looper持有MessageQueue的引用，Looper一直在等待MessageQueue中的新消息，一旦获取到新消息，Looper取出Message中的target，调用target.dispatchMessage()，消息最后被分发给Handler的Callback，整个流程就走完了 现在再看文章最开始的例子，应该能理解Handler的精髓了。再上一张图： 内存泄漏 最后再想一个问题，Handler怎么造成内存泄露的，以及如何避免。 什么是内存泄漏？ 给对象分配内存空间后，不再使用该对象时，GC也无法释放它占用的空间。比如，在Android中，结束掉Activity后，Activity占用的内存空间没有被释放，这时Activity就发生了内存泄漏。 Handler发生内存泄漏的代码通常如图所示： 编译器的提示很委婉：leaks might occur，可能会发生泄漏；所以使用内部类形式的Handler并不一定会发生内存泄漏。 匿名内部类Handler持有Activity的引用，Message持有Handler的引用，MessageQueue持有Message的引用，Looper持有MessageQueue的引用：Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity。主线程的Looper和应用的生命周期是相同的，如果Activity被finish()了，但Handler发送的消息还没有被处理，这时Activity是不会被JVM判定为可以回收的。 由此可以判断，Handler引发的内存泄漏是因为在Activity finish()之前调用了handler.postDelay()或者handler.sendMessageDelay()，在Activity被finish()后Handler还有未处理的消息导致的。 影响几何 由于上述原因导致的内存泄漏会带来什么样的影响？被泄漏的Activity一直都不会被回收吗？ JVM操作内存的垃圾回收，GC会一遍又一遍的、周而复始的扫描内存中存活的对象，如果该对象符合回收条件，就会被回收。 JVM有若干GC算法，比如，标记-清除、标记-复制、可达性分析等。像标记-清除，它分为两个阶段，先标记可回收的对象，等下次GC发生时清除被标记的对象。 假如Activity finish()之前调用了handler.postDelay({ //若干操作 }, 5000)，触发了5秒后的延时操作。在这5秒内GC可能对该Activity扫描了一次，也可能扫描了多次，每次扫描Activity GC都发现有引用指向它，所以肯定不会回收它；到第5秒，Runnable被Handler处理了，指向该Activity的Message也被回收，下次GC再次扫描Activity发现没有引用指向它，此时Activity即将被回收。 由此可以得出结论：由于Handler发送延迟消息导致的Activity内存泄漏，会在延迟消息被处理后，Activity才会被GC回收。Activity泄漏的时间长短取决于Handler发送的延迟消息的延迟时间。 解决内存泄漏 明确了Handler是怎么导致内存泄漏的，解决方案也很容易： Handler由内部类的形式改成静态内部类的形式，因为静态内部类不持有外部类的引用；Handler不持有Activity的引用，即便有延迟消息也不会发生内存泄漏 在Activity finish()之前调用handler.removeCallbacksAndMessages(null)，移除Handler中所有未处理的任务，这样也就避免了内存泄漏 具体使用什么样的策略取决于代码的业务场景。 这篇文章到此就结束了。本文介绍了Handler的工作流程，并分析了常见的几个Handler相关的面试问题。 ","link":"https://wanyt.github.io/post/handler-ji-zhi/"}]}